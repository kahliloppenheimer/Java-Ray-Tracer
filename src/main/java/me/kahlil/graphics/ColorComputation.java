package me.kahlil.graphics;

import java.util.Arrays;

public final class ColorComputation {

  private MutableColor color;

  private ColorComputation(MutableColor color) {
    this.color = color;
  }

  /**
   * Creates a new {@link ColorComputation} by copying the input so it is not modified.
   */
  public static ColorComputation of(MutableColor color) {
    return new ColorComputation(new MutableColor(Arrays.copyOf(color.getRgb(), 3)));
  }

  /**
   * Creates a new {@link ColorComputation} without copying the input. In other words, the input
   * will be modified in-place.
   */
  public static ColorComputation modifyingInPlace(MutableColor color) {
    return new ColorComputation(color);
  }

  /** Multiplies each component of each color by the other */
  public ColorComputation multiply(MutableColor second) {
    float[] firstRgb = this.color.getRgb();
    float[] secondRgb = second.getRgb();
    this.color.setRgb(
        firstRgb[0] * secondRgb[0],
        firstRgb[1] * secondRgb[1],
        firstRgb[2] * secondRgb[2]);
    return this;
  }

  /**
   * Returns the color generated by adding each RGB component of both colors. Will bound any results
   * to be within 0.0 to 1.0 inclusively.
   */
  public ColorComputation add(MutableColor second) {
    float[] firstRgb = this.color.getRgb();
    float[] secondRgb = second.getRgb();
    this.color.setRgb(
        bound(firstRgb[0] + secondRgb[0]),
        bound(firstRgb[1] + secondRgb[1]),
        bound(firstRgb[2] + secondRgb[2]));
    return this;
  }

  public ColorComputation scaleFloat(float scaleFactor) {
    float[] rgb = this.color.getRgb();
    this.color.setRgb(
        bound(rgb[0] * scaleFactor), bound(rgb[1] * scaleFactor), bound(rgb[2] * scaleFactor));
    return this;
  }

  public MutableColor compute() {
    return color;
  }

  private static float bound(float v) {
    return Math.min(Math.max(v, 0f), 1.0f);
  }
}
